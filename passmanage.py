#!/usr/bin/python3

#usage : passmanage entity
# entity is like 'alwaysdata', 'sncf'
# if entity is not found, partially, then we ask for a new account definition
# if multiples matchs, we display 'did u mean ' + matches

# for a new account, we ask :
# entity (example : website name)
# user (example : email)
# enter password (empty autogenerated)
# if empty we generate a password, and we display it




# what the command can do
# 1- passmanage add 
# 2- passmanage search string
# 3- passmanage init filelocation
# 4- passmanage remove string # remove if only one. If -f, (after remove) then force




# parse arg like git : http://chase-seibert.github.io/blog/2014/03/21/python-multilevel-argparse.html


import argparse
import base64
import binascii 
from Crypto.Cipher import XOR
import getpass
import json
import os.path
import random
import re
import string
import sys

config = os.environ['HOME'] + '/.config/passmanage'
default_conf = os.environ['HOME'] + '/passwords'

def add(params):
# params should be a list
	if (len(params) != 2):
		display_usage(command = 'add')
		sys.exit(1) # exit right away
		return None 
	key = get_db_pass() 
	pwlist = list_load(key)
	context = params[0]
	login = params[1]
	password = generate_pw()
	echo = "Enter password (%s) : " % password
	pwtemp = getpass.getpass(echo) 
	if (pwtemp == ""):
		pwtemp = password
	pwlist[context] = {"login": login, "password": password} 
	list_save(key, pwlist) 
	return None

def decrypt(key, ciphertext):
  cipher = XOR.new(key)
  return cipher.decrypt(base64.b64decode(ciphertext)).decode('utf-8')

def display_usage(**params):
	command = param('command', params)
	print("Usage :")
	if (command == 'init') or (command == ''):
		print("  %s init <file> : setup the crypted file to be used (%s default)" % (program_name(), default_conf))
	if (command == 'add') or (command == ''):
		print("  %s add <context> <login> : add a password for a given context." % (program_name()))
		print("    example : %s add context facebook foobar password_b4r" % (program_name()))
	if (command == 'search') or (command == ''):
		print("  %s search <context> : return a password." % (program_name()))
		print("    <context> is a regexp. If multiples match, return a list of matches without passwords")
	if (command == 'remove') or (command == ''):
		print("  %s remove <context> : remove the given context." % (program_name()))
		print("    <context> is a regexp. If multiples match, return a list of matches and remove none")
	# allow a -f for remove, maybe

def encrypt(key, plaintext):
  cipher = XOR.new(key)
  return base64.b64encode(cipher.encrypt(plaintext.encode('utf-8'))).decode('utf-8')

def generate_pw():
	random.seed()
	count=random.randrange(8,12)
	return ''.join(random.SystemRandom().choice(string.ascii_uppercase + string.digits) for _ in range(count))

def get_db_pass():
	return getpass.getpass('db file password : ')

def get_filename():
	if (os.path.exists(config)):
		with open(config, 'r') as infile:
			djson = infile.read() 
		datas = json.loads(djson)
		return datas['file']
	else:
		return default_conf

def init(params):
	if (len(params) != 1):
		display_usage(command = 'init')
		sys.exit(1) # exit right away
		return None
	else: 
		if (not(os.path.exists(os.path.dirname(config)))):
			os.makedirs(os.path.dirname(config))

		if (os.path.exists(default_conf)):
			with open(config, 'r') as infile:
				djson = infile.read() 
			datas = json.loads(djson)
		else:
			datas = {}

		datas['file'] = params[0]
		djson = json.dumps(datas) 
		with open(config, 'w') as outfile:
			outfile.write(djson) 
		return None 

def list_load(key): # open the file and return the list 
	filename = get_filename()
	if os.path.exists(filename):
		with open(filename, 'r') as infile:
			djson = infile.read() 
		djson = decrypt(key, djson) 
		return json.loads(djson)
	else:
		return {} 

def list_save(key, pwlist): # save the file 
	# print("will try to save : ")
	# print(pwlist)
	djson = json.dumps(pwlist)
	filename = get_filename()
	djson = encrypt(key, djson) 
	with open(filename, 'w') as outfile:
		outfile.write(djson) 
	return None 

def param(key, parlist):
	if key in parlist.keys():
		return parlist[key]
	else:
		return ''

def program_name():
	return os.path.basename(sys.argv[0])

def search(params): # params is a list of sys.argv 
	if (len(params) != 1):
		display_usage(command = 'search')
		sys.exit(1) # exit right away
		return None 
	reg = params[0]

	res = search_or_del(reg, 'return')
	if (res != None):
		print('Login : %s' % res['login'])
		print('Password : %s' % res['password']) 
	return None


def search_or_del(val, action):
	key = get_db_pass() 
	pwlist = list_load(key) 
	res = []
	for i in pwlist.keys():
		if (re.match(val, i) != None):
			res.append(i)
			login = pwlist[i]['login']
			password = pwlist[i]['password']

	if len(res) == 0:
		print("No result found")
		return None

	if len(res) > 1:
		print("Multiples results found :")
		print("\n".join(res))
		if (action == 'remove'):
			print("Nothing removed")
		return None


	if len(res) == 1:
		if action == 'return':
			return pwlist[res[0]]
		if action == 'remove':
			print(pwlist)
			del pwlist[res[0]]
			print(pwlist)
			print("%s removed" % res[0])
			list_save(key, pwlist)
			return 1


def remove(params):
	if (len(params) != 1):
		display_usage(command = 'remove')
		sys.exit(1) 
		return None 
	reg = params[0] 
	res = search_or_del(reg, 'remove')
	return None

def parse_main(param):
	list = {
		'add': add,
		'init': init,
		'search': search,
		'remove': remove}
	if (param in list.keys()):
		return list[param]
	else:
		return None
	
		
# we pass a pointer to the function. Each function will parse its arguments


def main():
	if len(sys.argv) < 2:
		display_usage()
		sys.exit(1)
	else:
		func = parse_main(sys.argv[1])
		if (func == None):
			display_usage()
			sys.exit(1)

		if (len(sys.argv) > 2):
			params = sys.argv[2:]
		else:
			params = []

		func(params)




main()
